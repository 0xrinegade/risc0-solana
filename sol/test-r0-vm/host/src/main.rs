// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.

use anyhow::Result;
use methods::{TEST_R0_VM_ELF, TEST_R0_VM_ID};
use risc0_circuit_recursion::control_id::BN254_IDENTITY_CONTROL_ID;
use risc0_groth16::{from_u256_hex, split_digest_bytes};
use risc0_groth16::{verifying_key_bytes, Seal};
// use risc0_solana;
use risc0_zkp::core::digest::Digest;
use risc0_zkvm::sha::Digestible;
use risc0_zkvm::VerifierContext;
use risc0_zkvm::{default_prover, ExecutorEnv};
use risc0_zkvm::{ProverOpts, ALLOWED_CONTROL_ROOT};

#[macro_export]
macro_rules! digest {
    ($s:literal) => {{
        const BYTES: [u8; risc0_zkp::core::digest::DIGEST_BYTES] =
            risc0_zkp::core::digest::hex!($s);
        risc0_zkp::core::digest::Digest::from_bytes(BYTES)
    }};
}
/// Convert Groth16 public inputs into bytes.
pub fn groth16_public_inputs_as_bytes(
    claim_digest: risc0_zkp::core::digest::Digest,
) -> Result<Vec<Vec<u8>>> {
    pub const ALLOWED_CONTROL_ROOT: Digest =
        digest!("a516a057c9fbf5629106300934d48e0e775d4230e41e503347cad96fcbde7e2e");

    pub const BN254_IDENTITY_CONTROL_ID: Digest =
        digest!("51b54a62f2aa599aef768744c95de8c7d89bf716e11b1179f05d6cf0bcfeb60e");
    let control_root = ALLOWED_CONTROL_ROOT;
    let bn254_control_id = BN254_IDENTITY_CONTROL_ID;

    // Split the digests into components
    let (a0, a1) = split_digest_bytes(control_root)?;
    let (c0, c1) = split_digest_bytes(claim_digest)?;

    // Reverse and convert the control ID
    let mut id_bn554 = bn254_control_id;
    id_bn554.as_mut_bytes().reverse();
    let id_bn254_fr = from_u256_hex(&hex::encode(id_bn554))?;

    // Collect all public inputs
    let public_inputs = vec![a0.into(), a1.into(), c0.into(), c1.into(), id_bn254_fr];

    Ok(public_inputs)
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let input: u32 = 15 * u32::pow(2, 27) + 1;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let receipt = default_prover()
        .prove_with_ctx(
            env,
            &VerifierContext::default(),
            TEST_R0_VM_ELF,
            &ProverOpts::groth16(),
        )
        .expect("failed to prove.")
        .receipt;

    println!("{:?}", receipt);

    let claim_digest = receipt.inner.claim().unwrap().as_value().unwrap().digest();
    let public_inputs = groth16_public_inputs_as_bytes(claim_digest).unwrap();

    let vk_raw = verifying_key_bytes();

    let seal = &receipt;

    println!("SEAL : {:?}", seal);
    println!("VERIFYING KEY : {:?}", vk_raw);
    println!("PUBLIC_INPUTS : {:?}", public_inputs);
}
